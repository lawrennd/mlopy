#!/usr/bin/env python
from netlab import *
import numpy as np
import matplotlib.pyplot as pp
import time

#"""DEMGMM1 Demonstrate EM for Gaussian mixtures.
#
#	Description
#	This script demonstrates the use of the EM algorithm to fit a mixture
#	of Gaussians to a set of data using maximum likelihood. A colour
#	coding scheme is used to illustrate the evaluation of the posterior
#	probabilities in the E-step of the EM algorithm.
#
#	See also
#	DEMGMM2, DEMGMM3, DEMGMM4, GMM, GMMEM, GMMPOST
#

#	Copyright (c) Ian T Nabney (1996-2001)
#        and Neil D. Lawrence (2009) (translation to python)"""

clc()
print "This demonstration illustrates the use of the EM (expectation-"
print "maximization) algorithm for fitting of a mixture of Gaussians to a"
print "data set by maximum likelihood."
print " "
print "The data set consists of 40 data points in a 2-dimensional"
print "space, generated by sampling from a mixture of 2 Gaussian"
print "distributions."
print " "
raw_input('Press return to see a plot of the data.')


# Generate the data
np.random.seed(0)
gmix = gmm(2, 2, 'spherical')
ndat1 = 20; ndat2 = 20; ndata = ndat1+ndat2
gmix.centres =  np.asarray([[0.3, 0.3], [0.7, 0.7]])
gmix.covars = np.asarray([0.01, 0.01])
x = gmix.samp(ndata)

h = pp.figure()
pp.axes(axisbg='w', frameon=True)
d = pp.plot(x[:, 0], x[:, 1], '.g', markersize=30)
pp.hold(True);  pp.axis('equal'); pp.axis([0, 1, 0, 1])
ht = pp.text(0.5, 1.05, 'Data', horizontalalignment='center')
pp.show()
print " "
raw_input('Press return to continue.')
pp.ioff()
clc()

print "We next create and initialize a mixture model consisting of a mixture"
print "of 2 Gaussians having ''spherical'' covariance matrices, using the"
print "function GMM. The Gaussian components can be displayed on the same"
print "plot as the data by drawing a contour of constant probability density"
print "for each component having radius equal to the corresponding standard"
print "deviation. Component 1 is coloured red and component 2 is coloured"
print "blue."
print " "
print "Note that a particulary poor choice of initial parameters has been"
print "made in order to illustrate more effectively the operation of the"
print "EM algorithm."
print " "
raw_input('Press return to see the initial configuration of the mixture model.')


# Set up mixture model
ncentres = 2; input_dim = 2
mix = gmm(input_dim, ncentres, 'spherical')

# Initialise the mixture model
mix.centres = np.asarray([[0.2, 0.8], [0.8, 0.2]])
mix.covars = np.asarray([0.01, 0.01])

# Plot the initial model
ncirc = 30; theta = np.linspace(0, 2*np.pi, ncirc)
xs = np.cos(theta); ys = np.sin(theta)
xvals = mix.centres[:, 0] + np.outer(xs, np.sqrt(mix.covars))
yvals = mix.centres[:, 1] + np.outer(ys, np.sqrt(mix.covars))
hc = []
hc.append(pp.plot(xvals[:,0], yvals[:,0], color='r'))
hc.append(pp.plot(xvals[:,1], yvals[:,1], color='b'))
pp.axis('equal'); pp.axis([0, 1, 0, 1])
pp.setp(ht, text='Initial Configuration')
pp.figure(h.number)
pp.show()
print " "
raw_input('Press return to continue') 
clc()
pp.ioff()
print "Now we adapt the parameters of the mixture model iteratively using the"
print "EM algorithm. Each cycle of the EM algorithm consists of an E-step"
print "followed by an M-step.  We start with the E-step, which involves the"
print "evaluation of the posterior probabilities (responsibilities) which the"
print "two components have for each of the data points."
print " "
print "Since we have labelled the two components using the colours red and"
print "blue, a convenient way to indicate the value of a posterior"
print "probability for a given data point is to colour the point using a"
print "scale ranging from pure red (corresponding to a posterior probability"
print "of 1.0 for the red component and 0.0 for the blue component) through"
print "to pure blue."
print " "
raw_input('Press return to see the result of applying the first E-step.')


# Initial E-step.
pp.setp(ht, text='E-step')
post = mix.post(x)[0]
dcols = np.c_[post[:,0], np.zeros((ndata, 1)), post[:,1]]
hd=[]
for i in range(ndata):
  hd.append(pp.plot(np.asmatrix(x[i, 0]), np.asmatrix(x[i, 1]), color=dcols[i,:], marker='.', markersize=30))
pp.axis('equal'); pp.axis([0, 1, 0, 1])
pp.figure(h.number)
pp.show()
print " "
raw_input('Press return to continue')
clc()
pp.ioff()
print "Next we perform the corresponding M-step. This involves replacing the"
print "centres of the component Gaussians by the corresponding weighted means"
print "of the data. Thus the centre of the red component is replaced by the"
print "mean of the data set, in which each data point is weighted according to"
print "the amount of red ink (corresponding to the responsibility of"
print "component 1 for explaining that data point). The variances and mixing"
print "proportions of the two components are similarly re-estimated."
print " "
raw_input('Press return to see the result of applying the first M-step.')


# M-step.
pp.setp(ht, text='M-step')
options = foptions() 
options[13] = 1 # A single iteration
options[0] = -1 # Switch off all messages, including warning
mix.em(x, options)
xvals = mix.centres[:, 0] + np.outer(xs, np.sqrt(mix.covars))
yvals = mix.centres[:, 1] + np.outer(ys, np.sqrt(mix.covars))
pp.setp(hc[0], xdata=xvals[:,0], ydata=yvals[:,0])
pp.setp(hc[1], xdata=xvals[:,1], ydata=yvals[:,1])
pp.figure(h.number)
print " "
pp.show()
raw_input('Press return to continue')
clc()
pp.ioff()

print "We can continue making alternate E and M steps until the changes in"
print "the log likelihood at each cycle become sufficiently small."
print " "
raw_input('Press return to see an animation of a further 9 EM cycles.')

pp.figure(h.number)

# Loop over EM iterations.
numiters = 9
for n in range(numiters):
  pp.setp(ht, text='E-step')
  post = mix.post(x)[0]
  dcols = np.c_[post[:,0], np.zeros((ndata, 1)), post[:,1]]
  pp.ioff()
  for i in range(ndata):
      pp.setp(hd[i], color=dcols[i, :])

  time.sleep(1)
  pp.setp(ht, text='M-step')
  mix.em(x, options)
  print 'Cycle ', n, '  Error ', options[7]
  xvals = mix.centres[:, 0] + np.outer(xs, np.sqrt(mix.covars))
  yvals = mix.centres[:, 1] + np.outer(ys, np.sqrt(mix.covars))
  pp.setp(hc[0], xdata=xvals[:,0], ydata=yvals[:,0])
  pp.setp(hc[1], xdata=xvals[:,1], ydata=yvals[:,1])
  pp.show()


print " ";
raw_input('Press return to end.')
clc(); pp.close(h)

